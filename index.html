<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>World-Swipe Survivor</title>
    <style>
        body { margin: 0; background: #111; overflow: hidden; color: white; font-family: sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; width: 100%; text-align: center; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div>Kills: <span id="kills">0</span></div>
        <small>Swipe to Turn World | Auto-Running UP</small>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- Game State ---
let worldAngle = 0; // The direction the world is "facing"
let runSpeed = 2;
let kills = 0;
const playerPos = { x: canvas.width / 2, y: canvas.height / 2 };
let enemies = [];
let bullets = [];

// --- Input Handling (Swiping) ---
let touchStartX = 0;
window.addEventListener('touchstart', e => touchStartX = e.touches[0].clientX);
window.addEventListener('touchmove', e => {
    let diff = e.touches[0].clientX - touchStartX;
    worldAngle += diff * 0.001; // Sensitivity
});
// Keyboard Fallback
const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

class Enemy {
    constructor() {
        // Spawn in a large circle far away from the player
        const spawnDist = 600;
        const angle = Math.random() * Math.PI * 2;
        this.worldX = Math.cos(angle) * spawnDist;
        this.worldY = Math.sin(angle) * spawnDist;
        this.emoji = "ðŸ§Ÿ";
    }
}

function update(time) {
    // 1. Handle Turning (Rotation)
    if (keys['ArrowLeft']) worldAngle -= 0.05;
    if (keys['ArrowRight']) worldAngle += 0.05;

    // 2. The "Endless Run" Logic
    // We move all enemies based on the current worldAngle and runSpeed
    // This makes it feel like the player is moving "Up" relative to the screen
    const moveX = Math.sin(worldAngle) * runSpeed;
    const moveY = Math.cos(worldAngle) * runSpeed;

    enemies.forEach(en => {
        // Move enemy towards player (the center 0,0 in world space)
        const angleToPlayer = Math.atan2(-en.worldY, -en.worldX);
        en.worldX += Math.cos(angleToPlayer) * 1.2; // Enemy speed
        en.worldY += Math.sin(angleToPlayer) * 1.2;

        // Apply World Scroll (The Run)
        en.worldX -= moveX;
        en.worldY += moveY;
    });

    // 3. Auto-Shoot (Targeting closest in world space)
    if (time % 60 < 1 && enemies.length > 0) {
        let nearest = enemies[0];
        let minDist = Infinity;
        enemies.forEach(en => {
            let d = Math.hypot(en.worldX, en.worldY);
            if(d < minDist) { minDist = d; nearest = en; }
        });
        bullets.push({ 
            x: 0, y: 0, 
            vx: (nearest.worldX / minDist) * 8, 
            vy: (nearest.worldY / minDist) * 8 
        });
    }

    // Update Bullets
    bullets.forEach((b, i) => {
        b.x += b.vx; b.y += b.vy;
        // Collision
        enemies.forEach((en, ei) => {
            if (Math.hypot(b.x - en.worldX, b.y - en.worldY) < 25) {
                enemies.splice(ei, 1);
                bullets.splice(i, 1);
                kills++;
                document.getElementById('kills').innerText = kills;
            }
        });
    });

    if (enemies.length < 20) enemies.push(new Enemy());
}

function draw() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(playerPos.x, playerPos.y);

    // Draw Background Grid (To show movement)
    ctx.strokeStyle = "#222";
    let gridSize = 100;
    // Simple visual to show movement:
    for(let i = -5; i < 5; i++) {
        ctx.beginPath(); ctx.moveTo(-500, i * gridSize); ctx.lineTo(500, i * gridSize); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(i * gridSize, -500); ctx.lineTo(i * gridSize, 500); ctx.stroke();
    }

    // Draw Enemies
    ctx.font = "30px serif";
    enemies.forEach(en => {
        ctx.fillText(en.emoji, en.worldX - 15, en.worldY + 15);
    });

    // Draw Bullets
    ctx.fillStyle = "cyan";
    bullets.forEach(b => {
        ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
    });

    // Draw Fixed Player
    ctx.font = "40px serif";
    ctx.fillText("ðŸ§™", -20, 15);

    ctx.restore();
    
    requestAnimationFrame((t) => { update(t); draw(); });
}

draw();
</script>
</body>
</html>
