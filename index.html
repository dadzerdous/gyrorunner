<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vampire Arena: Shield Edition</title>
    <style>
        body { margin: 0; background: #020105; overflow: hidden; color: #e0e0e0; font-family: 'Courier New', monospace; touch-action: none; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; width: 100%; text-align: center; pointer-events: none; z-index: 10; }
        .hud { font-size: 14px; font-weight: bold; color: #ff4444; margin-bottom: 2px; }
        #xp-bar-bg { width: 70%; height: 8px; background: #1a1a1a; margin: 0 auto; border: 1px solid #333; border-radius: 4px; }
        #xp-bar-fill { width: 0%; height: 100%; background: #00ffcc; border-radius: 3px; transition: width 0.2s; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; pointer-events: all; z-index: 20; }
        .card { background: #1a1a2e; border: 2px solid #444; padding: 15px; margin: 8px; width: 220px; text-align: center; border-radius: 12px; cursor: pointer; }
        .card:active { background: #333355; border-color: #00ffcc; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="hud">LVL <span id="lvl">1</span> | <span id="hp-icons">ðŸ©¸ðŸ©¸ðŸ©¸</span></div>
        <div id="xp-bar-bg"><div id="xp-bar-fill"></div></div>
    </div>

    <div id="overlay">
        <h2 style="color: #00ffcc; margin-bottom: 20px;">CHOOSE YOUR FATE</h2>
        <div id="choices"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- CONFIGURATION ---
const ARENA_SIZE = 450; // Much smaller, tighter arena
let gameState = "PLAYING";
let hp = 3, level = 1, xp = 0, xpNeeded = 4;
let invulnTimer = 0;

const player = {
    x: 0, y: 0, 
    speed: 3.2, 
    hasJump: false, 
    hasShield: false,
    jumpCD: 0, 
    shieldCD: 0,
    fireRate: 1100, 
    lastShot: 0,
    isJumping: false, 
    jumpTime: 0,
    isShielded: false, 
    shieldTime: 0
};

let enemies = [], bullets = [], enemyBullets = [], gems = [], shockwaves = [];

// --- MOVEMENT (JOYSTICK) ---
let joystick = { active: false, startX: 0, startY: 0, currX: 0, currY: 0 };
let moveDir = { x: 0, y: 0 };

window.addEventListener('touchstart', e => {
    joystick.active = true;
    joystick.startX = e.touches[0].clientX;
    joystick.startY = e.touches[0].clientY;
    joystick.currX = joystick.startX;
    joystick.currY = joystick.startY;
});

window.addEventListener('touchmove', e => {
    if (!joystick.active) return;
    joystick.currX = e.touches[0].clientX;
    joystick.currY = e.touches[0].clientY;
    
    let dx = joystick.currX - joystick.startX;
    let dy = joystick.currY - joystick.startY;
    let dist = Math.hypot(dx, dy);
    
    if (dist > 5) {
        moveDir.x = dx / dist;
        moveDir.y = dy / dist;
    }

    // Swipe Up for Skill
    if (dy < -60 && Math.abs(dx) < 30) {
        if (player.hasJump && player.jumpCD <= 0) { player.isJumping = true; player.jumpTime = 35; player.jumpCD = 200; }
        else if (player.hasShield && player.shieldCD <= 0) { player.isShielded = true; player.shieldTime = 180; player.shieldCD = 400; }
    }
});

window.addEventListener('touchend', () => { joystick.active = false; moveDir = { x: 0, y: 0 }; });

// Keyboard Fallback
const keys = {};
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === "Space") { // Manual jump fallback
         if (player.hasJump && player.jumpCD <= 0) { player.isJumping = true; player.jumpTime = 35; player.jumpCD = 200; }
    }
});
window.addEventListener('keyup', e => keys[e.code] = false);

class Enemy {
    constructor(type) {
        // Spawn strictly ALONG the inside edge of the border
        const side = Math.floor(Math.random() * 4);
        if (side === 0) { this.x = -ARENA_SIZE + 20; this.y = (Math.random()*2-1)*ARENA_SIZE; } // Left
        else if (side === 1) { this.x = ARENA_SIZE - 20; this.y = (Math.random()*2-1)*ARENA_SIZE; } // Right
        else if (side === 2) { this.y = -ARENA_SIZE + 20; this.x = (Math.random()*2-1)*ARENA_SIZE; } // Top
        else { this.y = ARENA_SIZE - 20; this.x = (Math.random()*2-1)*ARENA_SIZE; } // Bottom
        
        this.type = type;
        this.speed = type === 'shambler' ? 1.4 : 0.9;
        this.lastShot = 0;
    }
    update() {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);

        if (this.type === 'shambler') {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        } else {
            // Archer: Maintain distance
            if (dist > 220) { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
            else if (dist < 180) { this.x -= (dx / dist) * this.speed; this.y -= (dy / dist) * this.speed; }

            if (Date.now() - this.lastShot > 2800) {
                enemyBullets.push({ x: this.x, y: this.y, vx: (dx/dist)*3.5, vy: (dy/dist)*3.5 });
                this.lastShot = Date.now();
            }
        }

        if (dist < 22 && invulnTimer <= 0 && !player.isJumping) {
            if (player.isShielded) { player.isShielded = false; invulnTimer = 40; }
            else { hp--; invulnTimer = 60; updateHUD(); }
        }
    }
}

function updateHUD() {
    document.getElementById('hp-icons').innerText = "ðŸ©¸".repeat(Math.max(0, hp));
    document.getElementById('xp-bar-fill').style.width = (xp / xpNeeded * 100) + "%";
    document.getElementById('lvl').innerText = level;
    if (hp <= 0) { alert("Wasted. Rebirth?"); location.reload(); }
}

function levelUp() {
    gameState = "PAUSED";
    document.getElementById('overlay').style.display = 'flex';
    const container = document.getElementById('choices');
    container.innerHTML = "";
    
    const pool = [
        { id: 'JUMP', n: "Vampire Leap", d: "Unlock Jump (Swipe Up)" },
        { id: 'SHIELD', n: "Blood Shield", d: "Unlock Shield (Swipe Up)" },
        { id: 'SPEED', n: "Bat Wings", d: "Move Speed +15%" },
        { id: 'FIRE', n: "Rapid Thirst", d: "Fire Rate +20%" }
    ];

    // Filter out already owned skills
    let available = pool.filter(p => (p.id !== 'JUMP' || !player.hasJump) && (p.id !== 'SHIELD' || !player.hasShield));
    
    available.sort(() => 0.5 - Math.random()).slice(0, 2).forEach(opt => {
        let div = document.createElement('div');
        div.className = 'card';
        div.innerHTML = `<strong>${opt.n}</strong><br><small>${opt.d}</small>`;
        div.onclick = () => {
            if (opt.id === 'JUMP') player.hasJump = true;
            if (opt.id === 'SHIELD') player.hasShield = true;
            if (opt.id === 'SPEED') player.speed *= 1.15;
            if (opt.id === 'FIRE') player.fireRate *= 0.8;
            gameState = "PLAYING";
            document.getElementById('overlay').style.display = 'none';
        };
        container.appendChild(div);
    });
}

function update() {
    if (gameState !== "PLAYING") return;
    if (invulnTimer > 0) invulnTimer--;
    if (player.jumpCD > 0) player.jumpCD--;
    if (player.shieldCD > 0) player.shieldCD--;

    // Movement
    let mx = moveDir.x, my = moveDir.y;
    if (keys['KeyW'] || keys['ArrowUp']) my = -1;
    if (keys['KeyS'] || keys['ArrowDown']) my = 1;
    if (keys['KeyA'] || keys['ArrowLeft']) mx = -1;
    if (keys['KeyD'] || keys['ArrowRight']) mx = 1;

    player.x += mx * player.speed;
    player.y += my * player.speed;

    // Arena Constrain
    player.x = Math.max(-ARENA_SIZE + 15, Math.min(ARENA_SIZE - 15, player.x));
    player.y = Math.max(-ARENA_SIZE + 15, Math.min(ARENA_SIZE - 15, player.y));

    if (player.isJumping) {
        player.jumpTime--;
        if (player.jumpTime === 0) { 
            player.isJumping = false; 
            shockwaves.push({ x: player.x, y: player.y, r: 10, op: 1 }); 
        }
    }
    if (player.isShielded) {
        player.shieldTime--;
        if (player.shieldTime <= 0) player.isShielded = false;
    }

    // Enemies
    if (Math.random() < 0.025 && enemies.length < 15) {
        enemies.push(new Enemy(Math.random() > 0.4 ? 'shambler' : 'archer'));
    }

    enemies.forEach((en, i) => {
        en.update();
        bullets.forEach((b, bi) => {
            if (Math.hypot(b.x - en.x, b.y - en.y) < 25) {
                gems.push({ x: en.x, y: en.y });
                enemies.splice(i, 1);
                bullets.splice(bi, 1);
            }
        });
    });

    // Bullets
    enemyBullets.forEach((eb, i) => {
        eb.x += eb.vx; eb.y += eb.vy;
        if (Math.hypot(eb.x - player.x, eb.y - player.y) < 15 && !player.isJumping) {
            if (player.isShielded) { player.isShielded = false; } else { hp--; }
            enemyBullets.splice(i, 1); updateHUD();
        }
        if (Math.abs(eb.x) > ARENA_SIZE || Math.abs(eb.y) > ARENA_SIZE) enemyBullets.splice(i, 1);
    });

    bullets.forEach((b, i) => {
        b.x += b.vx; b.y += b.vy;
        if (Math.abs(b.x) > ARENA_SIZE || Math.abs(b.y) > ARENA_SIZE) bullets.splice(i, 1);
    });

    // Gems
    gems.forEach((g, i) => {
        const d = Math.hypot(g.x - player.x, g.y - player.y);
        if (d < 120) { g.x += (player.x - g.x)/d*6; g.y += (player.y - g.y)/d*6; }
        if (d < 15) { 
            gems.splice(i, 1); xp++; 
            if (xp >= xpNeeded) { xp=0; xpNeeded += 2; level++; levelUp(); } 
            updateHUD(); 
        }
    });

    // Auto-Shoot
    if (Date.now() - player.lastShot > player.fireRate && enemies.length > 0) {
        let nearest = enemies.reduce((a, b) => Math.hypot(a.x-player.x, a.y-player.y) < Math.hypot(b.x-player.x, b.y-player.y) ? a : b);
        let dist = Math.hypot(nearest.x - player.x, nearest.y - player.y);
        bullets.push({ x: player.x, y: player.y, vx: ((nearest.x-player.x)/dist)*9, vy: ((nearest.y-player.y)/dist)*9 });
        player.lastShot = Date.now();
    }
}

function draw() {
    update();
    ctx.fillStyle = '#050208';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(canvas.width/2 - player.x, canvas.height/2 - player.y);

    // Arena Floor Grid
    ctx.strokeStyle = '#150a24';
    for(let i = -ARENA_SIZE; i <= ARENA_SIZE; i += 50) {
        ctx.beginPath(); ctx.moveTo(i, -ARENA_SIZE); ctx.lineTo(i, ARENA_SIZE); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-ARENA_SIZE, i); ctx.lineTo(ARENA_SIZE, i); ctx.stroke();
    }

    // Border
    ctx.strokeStyle = "#ff0044"; ctx.lineWidth = 4;
    ctx.strokeRect(-ARENA_SIZE, -ARENA_SIZE, ARENA_SIZE*2, ARENA_SIZE*2);

    // Sprites
    ctx.font = "24px serif";
    enemies.forEach(en => ctx.fillText(en.type === 'shambler' ? "ðŸ§Ÿ" : "ðŸ¹", en.x - 12, en.y + 12));
    gems.forEach(g => ctx.fillText("ðŸ’Ž", g.x - 10, g.y + 10));
    
    ctx.fillStyle = "#00ffff"; bullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill(); });
    ctx.fillStyle = "#ff4444"; enemyBullets.forEach(eb => { ctx.beginPath(); ctx.arc(eb.x, eb.y, 5, 0, Math.PI*2); ctx.fill(); });

    shockwaves.forEach((sw, i) => {
        ctx.strokeStyle = `rgba(0, 255, 204, ${sw.op})`;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(sw.x, sw.y, sw.r, 0, Math.PI*2); ctx.stroke();
        sw.r += 6; sw.op -= 0.03; if (sw.op <= 0) shockwaves.splice(i, 1);
    });

    // Player
    if (player.isShielded) {
        ctx.strokeStyle = "rgba(0, 255, 255, 0.6)"; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.arc(player.x, player.y, 35, 0, Math.PI*2); ctx.stroke();
    }
    ctx.font = (player.isJumping ? 45 : 32) + "px serif";
    if (invulnTimer % 10 < 5) ctx.fillText("ðŸ§›", player.x - 16, player.y + 12);

    ctx.restore();

    // Virtual Joystick UI
    if (joystick.active) {
        ctx.strokeStyle = "rgba(255,255,255,0.15)"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(joystick.startX, joystick.startY, 50, 0, Math.PI*2); ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,0.1)";
        ctx.beginPath(); ctx.arc(joystick.currX, joystick.currY, 25, 0, Math.PI*2); ctx.fill();
    }

    requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
