<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vampire Drift - Precision Combat</title>
    <style>
        body { margin: 0; background: #050208; overflow: hidden; color: #e0e0e0; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; }
        .hud-text { font-size: 24px; font-weight: bold; letter-spacing: 2px; color: #ff3333; text-shadow: 2px 2px 4px #000; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="hud-text">KILLS: <span id="kills">0</span></div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let kills = 0;
let worldRotation = 0;
let targetRotation = 0;
const scrollSpeed = 4.5;
const playerPos = { x: canvas.width / 2, y: canvas.height / 2 };

// Combat Balancing
let lastShotTime = 0;
const fireRate = 1200; // Shoot once every 1.2 seconds

let enemies = [];
let bullets = [];
const gridSize = 128;
let worldX = 0;
let worldY = 0;

// Inputs
let touchStart = 0;
window.addEventListener('touchstart', e => touchStart = e.touches[0].clientX);
window.addEventListener('touchend', e => {
    let diff = e.changedTouches[0].clientX - touchStart;
    if (Math.abs(diff) > 40) targetRotation += (diff > 0 ? 1 : -1) * (95 * Math.PI / 180);
});
window.addEventListener('keydown', e => {
    if (e.key === "ArrowLeft") targetRotation -= (95 * Math.PI / 180);
    if (e.key === "ArrowRight") targetRotation += (95 * Math.PI / 180);
});

class Enemy {
    constructor() {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.max(canvas.width, canvas.height);
        this.x = Math.cos(angle) * dist;
        this.y = Math.sin(angle) * dist;
        this.speed = 2.0 + Math.random();
    }
    update(vx, vy) {
        this.x += vx;
        this.y += vy;
        const dx = 0 - this.x;
        const dy = 0 - this.y;
        const d = Math.hypot(dx, dy);
        if (d > 5) {
            this.x += (dx / d) * this.speed;
            this.y += (dy / d) * this.speed;
        }
    }
}

function update(currentTime) {
    worldRotation += (targetRotation - worldRotation) * 0.08;
    const vx = Math.sin(worldRotation) * scrollSpeed;
    const vy = -Math.cos(worldRotation) * scrollSpeed;
    worldX += vx;
    worldY += vy;

    // Spawn enemies
    if (Math.random() < 0.03 && enemies.length < 25) enemies.push(new Enemy());
    enemies.forEach((en, i) => {
        en.update(vx, vy);
        if (Math.hypot(en.x, en.y) > 1500) enemies.splice(i, 1);
    });

    // Precision Auto-Shoot
    if (currentTime - lastShotTime > fireRate && enemies.length > 0) {
        let nearest = enemies.reduce((a, b) => Math.hypot(a.x, a.y) < Math.hypot(b.x, b.y) ? a : b);
        let d = Math.hypot(nearest.x, nearest.y);
        
        // Shoot if within a reasonable range
        if (d < 600) {
            bullets.push({
                x: 0, y: 0,
                vx: (nearest.x / d) * 14, // Faster bullet travel
                vy: (nearest.y / d) * 14
            });
            lastShotTime = currentTime;
        }
    }

    // Bullet Physics and Collision
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.x += b.vx;
        b.y += b.vy;
        // Subtle drift movement
        b.x += vx * 0.4;
        b.y += vy * 0.4;

        let hit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
            let en = enemies[j];
            if (Math.hypot(b.x - en.x, b.y - en.y) < 35) {
                enemies.splice(j, 1); // Remove enemy
                hit = true;
                kills++;
                document.getElementById('kills').innerText = kills;
                break; // Stop checking enemies for this bullet
            }
        }

        if (hit || Math.hypot(b.x, b.y) > 1000) {
            bullets.splice(i, 1); // Remove bullet on hit or range limit
        }
    }
}

function draw(currentTime) {
    update(currentTime);
    ctx.fillStyle = '#0a0510';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(playerPos.x, playerPos.y);

    // Grid
    ctx.strokeStyle = '#1e133a';
    ctx.lineWidth = 1;
    const startX = (worldX % gridSize) - canvas.width;
    const endX = (worldX % gridSize) + canvas.width;
    const startY = (worldY % gridSize) - canvas.height;
    const endY = (worldY % gridSize) + canvas.height;

    for (let x = startX; x < endX; x += gridSize) {
        ctx.beginPath(); ctx.moveTo(x, -canvas.height); ctx.lineTo(x, canvas.height); ctx.stroke();
    }
    for (let y = startY; y < endY; y += gridSize) {
        ctx.beginPath(); ctx.moveTo(-canvas.width, y); ctx.lineTo(canvas.width, y); ctx.stroke();
    }

    // Enemies
    ctx.font = "32px serif";
    enemies.forEach(en => ctx.fillText("ðŸ§Ÿ", en.x - 16, en.y + 16));

    // Bullets
    bullets.forEach(b => {
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#0ff';
        ctx.beginPath(); ctx.arc(b.x, b.y, 5, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
    });

    // Player
    ctx.font = "50px serif";
    ctx.textAlign = "center";
    ctx.shadowBlur = 20;
    ctx.shadowColor = "red";
    ctx.fillText("ðŸ§›", 0, 15);
    ctx.shadowBlur = 0;

    ctx.restore();
    requestAnimationFrame(draw);
}

requestAnimationFrame(draw);
</script>
</body>
</html>
