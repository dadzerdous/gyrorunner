<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smooth Vampire Drift</title>
    <style>
        body { margin: 0; background: #050208; overflow: hidden; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; }
        .hud-text { font-size: 24px; font-weight: bold; letter-spacing: 2px; color: #ff3333; text-shadow: 2px 2px 4px #000; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="hud-text">KILLS: <span id="kills">0</span></div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let kills = 0;
let worldRotation = 0;
let targetRotation = 0;
const scrollSpeed = 4.5;
const playerPos = { x: canvas.width / 2, y: canvas.height / 2 };

let enemies = [];
let bullets = [];

// --- Background Logic ---
// We'll use a "virtual grid" to draw the background so it looks infinite
const gridSize = 128;
let worldX = 0;
let worldY = 0;

// Input
let touchStart = 0;
window.addEventListener('touchstart', e => touchStart = e.touches[0].clientX);
window.addEventListener('touchend', e => {
    let diff = e.changedTouches[0].clientX - touchStart;
    if (Math.abs(diff) > 40) targetRotation += (diff > 0 ? 1 : -1) * (95 * Math.PI / 180);
});
window.addEventListener('keydown', e => {
    if (e.key === "ArrowLeft") targetRotation -= (95 * Math.PI / 180);
    if (e.key === "ArrowRight") targetRotation += (95 * Math.PI / 180);
});

class Enemy {
    constructor() {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.max(canvas.width, canvas.height);
        // Spawn relative to screen center
        this.x = Math.cos(angle) * dist;
        this.y = Math.sin(angle) * dist;
        this.speed = 2.2 + Math.random();
    }
    update(vx, vy) {
        // 1. Apply World Drift (Keeps them moving with the background)
        this.x += vx;
        this.y += vy;

        // 2. Accurate Homing (Move toward 0,0 which is the player)
        const dx = 0 - this.x;
        const dy = 0 - this.y;
        const d = Math.hypot(dx, dy);
        
        // Only home in if they are not already on top of the player
        if (d > 5) {
            this.x += (dx / d) * this.speed;
            this.y += (dy / d) * this.speed;
        }
    }
}

function update() {
    // Interpolate rotation for smoothness
    worldRotation += (targetRotation - worldRotation) * 0.08;

    // Movement Vector
    const vx = Math.sin(worldRotation) * scrollSpeed;
    const vy = -Math.cos(worldRotation) * scrollSpeed;

    // Shift the "World" coordinates (for the background)
    worldX += vx;
    worldY += vy;

    // Enemies
    if (Math.random() < 0.04 && enemies.length < 30) enemies.push(new Enemy());
    enemies.forEach((en, i) => {
        en.update(vx, vy);
        if (Math.hypot(en.x, en.y) > 1200) enemies.splice(i, 1);
    });

    // Auto-Shoot
    if (Date.now() % 400 < 20 && enemies.length > 0) {
        let nearest = enemies.reduce((a, b) => Math.hypot(a.x, a.y) < Math.hypot(b.x, b.y) ? a : b);
        let d = Math.hypot(nearest.x, nearest.y);
        bullets.push({
            x: 0, y: 0,
            vx: (nearest.x / d) * 12,
            vy: (nearest.y / d) * 12
        });
    }

    bullets.forEach((b, i) => {
        b.x += b.vx; b.y += b.vy;
        // Bullets are affected by world drift slightly so they don't look "detached"
        b.x += vx * 0.5;
        b.y += vy * 0.5;

        enemies.forEach((en, ei) => {
            if (Math.hypot(b.x - en.x, b.y - en.y) < 30) {
                enemies.splice(ei, 1);
                bullets.splice(i, 1);
                kills++;
                document.getElementById('kills').innerText = kills;
            }
        });
        if (Math.hypot(b.x, b.y) > 1000) bullets.splice(i, 1);
    });
}

function draw() {
    // Clear with dark purple/black gradient
    ctx.fillStyle = '#0a0510';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(playerPos.x, playerPos.y);

    // --- Draw Tiled Background ---
    ctx.strokeStyle = '#1a0f2e';
    ctx.lineWidth = 2;
    const startX = (worldX % gridSize) - canvas.width;
    const endX = (worldX % gridSize) + canvas.width;
    const startY = (worldY % gridSize) - canvas.height;
    const endY = (worldY % gridSize) + canvas.height;

    for (let x = startX; x < endX; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, -canvas.height);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for (let y = startY; y < endY; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(-canvas.width, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }

    // --- Draw Enemies ---
    ctx.font = "32px serif";
    enemies.forEach(en => {
        ctx.fillText("ðŸ§Ÿ", en.x - 16, en.y + 16);
    });

    // --- Draw Bullets ---
    bullets.forEach(b => {
        ctx.fillStyle = '#ff0';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ff0';
        ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
    });

    // --- Draw Player ---
    ctx.font = "50px serif";
    ctx.textAlign = "center";
    ctx.shadowBlur = 15;
    ctx.shadowColor = "red";
    ctx.fillText("ðŸ§›", 0, 15);
    ctx.shadowBlur = 0;

    ctx.restore();
    
    update();
    requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
