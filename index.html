<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vampire Shockwave</title>
    <style>
        body { margin: 0; background: #050208; overflow: hidden; color: #e0e0e0; font-family: sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; }
        .hud { font-size: 24px; font-weight: bold; color: #ff3333; text-shadow: 2px 2px 4px #000; }
        #game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 20px; border: 2px solid red; display: none; text-align: center; pointer-events: all; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="hud">HP: <span id="hp">ðŸ©¸ðŸ©¸ðŸ©¸</span> | KILLS: <span id="kills">0</span></div>
    </div>
    <div id="game-over">
        <h1>WASTED</h1>
        <button onclick="location.reload()" style="padding: 10px 20px; cursor: pointer;">REBIRTH</button>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let kills = 0;
let hp = 3;
let invulnTimer = 0;
let worldRotation = 0;
let targetRotation = 0;
const scrollSpeed = 4.5;
const playerPos = { x: canvas.width / 2, y: canvas.height / 2 };

// Jump/Shockwave Logic
let isJumping = false;
let jumpTime = 0;
let shockwaves = [];

let lastShotTime = 0;
const fireRate = 1200;
let enemies = [];
let bullets = [];
const gridSize = 128;
let worldX = 0, worldY = 0;

// Inputs
let touchStartY = 0;
let touchStartX = 0;

window.addEventListener('touchstart', e => {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
});

window.addEventListener('touchend', e => {
    let diffX = e.changedTouches[0].clientX - touchStartX;
    let diffY = e.changedTouches[0].clientY - touchStartY;

    if (Math.abs(diffY) > 60 && diffY < 0 && !isJumping) {
        startJump(); // Swipe Up
    } else if (Math.abs(diffX) > 40) {
        targetRotation += (diffX > 0 ? 1 : -1) * (95 * Math.PI / 180);
    }
});

window.addEventListener('keydown', e => {
    if (e.key === "ArrowLeft") targetRotation -= (95 * Math.PI / 180);
    if (e.key === "ArrowRight") targetRotation += (95 * Math.PI / 180);
    if (e.code === "Space" && !isJumping) startJump();
});

function startJump() {
    isJumping = true;
    jumpTime = 40; // frames
}

function triggerShockwave() {
    shockwaves.push({ r: 10, maxR: 200, opacity: 1 });
}

class Enemy {
    constructor() {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.max(canvas.width, canvas.height);
        this.x = Math.cos(angle) * dist;
        this.y = Math.sin(angle) * dist;
        this.speed = 2.0 + Math.random();
    }
    update(vx, vy) {
        this.x += vx; this.y += vy;
        const dx = 0 - this.x; const dy = 0 - this.y;
        const d = Math.hypot(dx, dy);
        if (d > 5) {
            this.x += (dx / d) * this.speed;
            this.y += (dy / d) * this.speed;
        }

        // Collision with player
        if (d < 30 && invulnTimer <= 0 && !isJumping) {
            hp--;
            invulnTimer = 60;
            document.getElementById('hp').innerText = "ðŸ©¸".repeat(hp);
            if (hp <= 0) document.getElementById('game-over').style.display = 'block';
        }
    }
}

function update(currentTime) {
    if (hp <= 0) return;
    if (invulnTimer > 0) invulnTimer--;

    worldRotation += (targetRotation - worldRotation) * 0.08;
    const vx = Math.sin(worldRotation) * scrollSpeed;
    const vy = -Math.cos(worldRotation) * scrollSpeed;
    worldX += vx; worldY += vy;

    // Jump handling
    if (isJumping) {
        jumpTime--;
        if (jumpTime === 0) {
            isJumping = false;
            triggerShockwave();
        }
    }

    // Shockwave damage
    shockwaves.forEach((sw, si) => {
        sw.r += 8;
        sw.opacity -= 0.02;
        if (sw.opacity <= 0) shockwaves.splice(si, 1);
        
        enemies.forEach((en, ei) => {
            let d = Math.hypot(en.x, en.y);
            if (Math.abs(d - sw.r) < 20) {
                enemies.splice(ei, 1);
                kills++;
                document.getElementById('kills').innerText = kills;
            }
        });
    });

    if (Math.random() < 0.03 && enemies.length < 25) enemies.push(new Enemy());
    enemies.forEach((en, i) => en.update(vx, vy));

    // Shooting logic
    if (currentTime - lastShotTime > fireRate && enemies.length > 0) {
        let nearest = enemies.reduce((a, b) => Math.hypot(a.x, a.y) < Math.hypot(b.x, b.y) ? a : b);
        let d = Math.hypot(nearest.x, nearest.y);
        if (d < 600) {
            bullets.push({ x: 0, y: 0, vx: (nearest.x / d) * 14, vy: (nearest.y / d) * 14 });
            lastShotTime = currentTime;
        }
    }

    bullets.forEach((b, i) => {
        b.x += b.vx + vx * 0.4;
        b.y += b.vy + vy * 0.4;
        enemies.forEach((en, ei) => {
            if (Math.hypot(b.x - en.x, b.y - en.y) < 35) {
                enemies.splice(ei, 1);
                bullets.splice(i, 1);
                kills++;
                document.getElementById('kills').innerText = kills;
            }
        });
    });
}

function draw(currentTime) {
    update(currentTime);
    ctx.fillStyle = '#0a0510';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(playerPos.x, playerPos.y);

    // Background Grid
    ctx.strokeStyle = '#1e133a';
    for (let x = (worldX % gridSize) - canvas.width; x < canvas.width; x += gridSize) {
        ctx.beginPath(); ctx.moveTo(x, -canvas.height); ctx.lineTo(x, canvas.height); ctx.stroke();
    }
    for (let y = (worldY % gridSize) - canvas.height; y < canvas.height; y += gridSize) {
        ctx.beginPath(); ctx.moveTo(-canvas.width, y); ctx.lineTo(canvas.width, y); ctx.stroke();
    }

    // Shockwaves
    shockwaves.forEach(sw => {
        ctx.strokeStyle = `rgba(255, 0, 0, ${sw.opacity})`;
        ctx.lineWidth = 5;
        ctx.beginPath(); ctx.arc(0, 0, sw.r, 0, Math.PI * 2); ctx.stroke();
    });

    // Enemies
    ctx.font = "32px serif";
    enemies.forEach(en => ctx.fillText("ðŸ§Ÿ", en.x - 16, en.y + 16));

    // Bullets
    ctx.fillStyle = '#fff';
    bullets.forEach(b => {
        ctx.beginPath(); ctx.arc(b.x, b.y, 5, 0, Math.PI * 2); ctx.fill();
    });

    // Player with Jump visual
    let scale = isJumping ? 1.5 : 1;
    ctx.font = (50 * scale) + "px serif";
    ctx.textAlign = "center";
    if (invulnTimer % 10 < 5) { // Flashing effect
        ctx.shadowBlur = 20; ctx.shadowColor = "red";
        ctx.fillText("ðŸ§›", 0, 15);
    }
    
    ctx.restore();
    requestAnimationFrame(draw);
}
requestAnimationFrame(draw);
</script>
</body>
</html>
